<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <title>Painel de Fotos</title>
  <meta name="viewport" content="width=248, height=448, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div id="app">
    <div id="stage">
      <div id="track"></div>
    </div>

  </div>

  <script>
    const FEED_URL = "http://192.168.1.37:4000/feed.json"; // URL para o feed
    const INTERVALO_MS = 30000;

    // métricas do seu layout
    const POLAROID_H = 230;
    const GAP = 40;
    const STEP = POLAROID_H + GAP;

    // velocidade do loop (px por segundo). Aumente para ficar mais rápido.
    const SPEED_PX_PER_SEC = 90;

    function ordenarPorDataDesc(items) {
      return items.slice().sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    }

    function criarPolaroid(item) {
      const p = document.createElement("div");
      p.className = "polaroid";

      const img = document.createElement("img");
      img.src = item.url.startsWith('http') ? item.url : "http://192.168.1.37:4000" + item.url;
      img.alt = item.caption || "foto";
      p.appendChild(img);

      return p;
    }

    function setInfo(txt) {
      document.getElementById("info").textContent = txt;
    }

    function montarLoop(items) {
      const track = document.getElementById("track");

      // Se não houverem imagens, exibe a mensagem
      if (!items || items.length === 0) {
        setInfo("nenhuma imagem no feed");
        return;
      }

      // Ordena do mais recente para o mais antigo
      let ordered = ordenarPorDataDesc(items);

      // Remove imagens antigas (para evitar duplicações)
      track.innerHTML = "";

      // Adiciona as fotos várias vezes para garantir o loop contínuo
      // (quanto mais, mais suave o loop)
      for (let i = 0; i < 4; i++) {
        for (const it of ordered) {
          track.appendChild(criarPolaroid(it));
        }
      }

      // Ajusta a distância para o número total de polaroids renderizadas
      const totalPolaroids = track.childElementCount;
      const distance = STEP * totalPolaroids;
      track.style.setProperty("--scroll-distance", `${distance}px`);

      // Calcula a duração da animação baseada na distância e na velocidade
      const durationSec = distance / SPEED_PX_PER_SEC;
      track.style.setProperty("--scroll-duration", `${durationSec}s`);

      // Inicia a animação infinita (sem reiniciar)
      track.classList.add("run");

      // Inicia o efeito de destaque quando a polaroid estiver totalmente visível
      startFullVisibleEffect(track);
    }

    // Função para destacar a polaroid quando ela estiver totalmente visível no stage
    function startFullVisibleEffect(track) {
      // Armazena o tempo em que cada polaroid ficou totalmente visível
      const visibleSince = new Map();
      const DELAY_MS = 200; // tempo mínimo totalmente visível para crescer

      function highlight() {
        const stage = document.getElementById("stage");
        const stageRect = stage.getBoundingClientRect();
        let bestPolaroid = null;
        let maxVisible = 0;
        const now = Date.now();
        for (const p of track.children) {
          const rect = p.getBoundingClientRect();
          // Calcular a parte visível da polaroid dentro do stage
          const visibleTop = Math.max(rect.top, stageRect.top);
          const visibleBottom = Math.min(rect.bottom, stageRect.bottom);
          const visibleHeight = Math.max(0, visibleBottom - visibleTop);
          const percentVisible = visibleHeight / rect.height;
          if (percentVisible > maxVisible) {
            maxVisible = percentVisible;
            bestPolaroid = p;
          }
          // Controle de tempo de visibilidade
          if (percentVisible > 0.99) {
            if (!visibleSince.has(p)) visibleSince.set(p, now);
          } else {
            visibleSince.delete(p);
          }
        }
        // Remove destaque de todas
        for (const p of track.children) {
          p.classList.remove("center");
        }
        // Destaca a mais visível se estiver pelo menos 99% visível por tempo suficiente
        if (bestPolaroid && maxVisible > 0.99 && visibleSince.has(bestPolaroid)) {
          if (now - visibleSince.get(bestPolaroid) > DELAY_MS) {
            bestPolaroid.classList.add("center");
          }
        }
        requestAnimationFrame(highlight);
      }
      requestAnimationFrame(highlight);
    }

    async function carregarFeed() {
      try {
        const res = await fetch(FEED_URL, {
          cache: "no-store"
        });
        const feed = await res.json();
        montarLoop(feed.items || []);
      } catch (e) {
        setInfo("EM MANUTENÇÃO!!");
      }
    }

    // Carrega o feed assim que a página é carregada
    carregarFeed();
    // Recarrega o feed a cada 30 segundos
    setInterval(carregarFeed, INTERVALO_MS);
  </script>
</body>
</html>


